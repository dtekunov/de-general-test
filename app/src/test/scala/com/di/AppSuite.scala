/*
 * This Scala Testsuite was generated by the Gradle 'init' task.
 */
package com.di

import com.di.io.KeyValuePair
import com.di.logic.Evaluation
import com.typesafe.config.{Config, ConfigFactory}
import org.apache.log4j.{Level, LogManager, Logger}
import org.apache.spark.SparkException
import org.apache.spark.sql.SparkSession
import org.scalatest.funsuite.AnyFunSuite
import org.junit.runner.RunWith
import org.scalatest.matchers.must.Matchers
import org.scalatestplus.junit.JUnitRunner

@RunWith(classOf[JUnitRunner])
class AppSuite extends AnyFunSuite with Matchers {
  val config: Config = ConfigFactory
    .load("application.conf")
    .getConfig("main")

  val logger: Logger = LogManager.getRootLogger
  logger.setLevel(Level.WARN)

  implicit val spark: SparkSession = SparkSession
    .builder()
    .appName("test")
    .master("local[*]")
    .getOrCreate()

  import spark.implicits._

  test("All Algorithms should work correctly on a base case") {
    val values = Seq(
      (1, 2),
      (1, 3),
      (1, 3),
      (2, 4),
      (2, 4),
      (2, 4)
    ).toDF("key", "value")

    val (result1, result2) = {
      val evaluation = new Evaluation

      (evaluation.algorithmV1(values).collect(), evaluation.algorithmV2(values).collect())
    }

    result1 must contain theSameElementsAs result2
    result1 must contain theSameElementsAs Array(KeyValuePair(1, 2), KeyValuePair(2, 4))
  }

  test("All Algorithms should fail on non-valid data") {
    val values = Seq(
      (1, 2),
      (1, 2),
    ).toDF("key", "value")
    val evaluation = new Evaluation

    assertThrows[SparkException] {
        evaluation.algorithmV1(values).collect()
    }
  }

  test("All Algorithms should work correctly with a random input") {
    val values = TestValuesGenerator.generateRandomTestInput

    val (result1, result2) = {
      val evaluation = new Evaluation

      (evaluation.algorithmV1(values.allValues.toDF("key", "value")).collect(),
        evaluation.algorithmV2(values.allValues.toDF("key", "value")).collect())
    }

    result1 must contain theSameElementsAs values.valuesToFind
    result1 must contain theSameElementsAs result2
  }
}
